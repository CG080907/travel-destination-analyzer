# Travel Destination Analyzer with Weather and Cost Forecast
# Main Application File

import tkinter as tk
from tkinter import ttk, messagebox
import folium
from folium import plugins
import webbrowser
import os
from datetime import datetime, timedelta
import json

# ============================================================================
# DATA COLLECTION MODULE (weather_api.py)
# ============================================================================

class WeatherAPI:
    """Handles weather data collection and forecasting"""
    
    def __init__(self, api_key=None):
        self.api_key = api_key or "YOUR_OPENWEATHERMAP_API_KEY"
        # Sample destinations with coordinates
        self.destinations = {
            "Paris": {"lat": 48.8566, "lon": 2.3522, "country": "France"},
            "Tokyo": {"lat": 35.6762, "lon": 139.6503, "country": "Japan"},
            "New York": {"lat": 40.7128, "lon": -74.0060, "country": "USA"},
            "Barcelona": {"lat": 41.3874, "lon": 2.1686, "country": "Spain"},
            "Bali": {"lat": -8.3405, "lon": 115.0920, "country": "Indonesia"},
            "Dubai": {"lat": 25.2048, "lon": 55.2708, "country": "UAE"},
            "London": {"lat": 51.5074, "lon": -0.1278, "country": "UK"},
            "Sydney": {"lat": -33.8688, "lon": 151.2093, "country": "Australia"},
        }
    
    def get_weather_forecast(self, destination):
        """Simulates weather API call - replace with real API in production"""
        # Seasonal patterns (simplified)
        month = datetime.now().month
        
        weather_patterns = {
            "Paris": {
                "winter": {"temp": 7, "rain": 0.6, "condition": "Cloudy"},
                "spring": {"temp": 15, "rain": 0.4, "condition": "Mild"},
                "summer": {"temp": 25, "rain": 0.3, "condition": "Sunny"},
                "fall": {"temp": 12, "rain": 0.5, "condition": "Rainy"}
            },
            "Tokyo": {
                "winter": {"temp": 10, "rain": 0.3, "condition": "Cold"},
                "spring": {"temp": 18, "rain": 0.4, "condition": "Cherry Blossoms"},
                "summer": {"temp": 28, "rain": 0.6, "condition": "Hot & Humid"},
                "fall": {"temp": 20, "rain": 0.4, "condition": "Pleasant"}
            },
            "Bali": {
                "winter": {"temp": 27, "rain": 0.7, "condition": "Rainy Season"},
                "spring": {"temp": 28, "rain": 0.4, "condition": "Warm"},
                "summer": {"temp": 27, "rain": 0.2, "condition": "Dry & Sunny"},
                "fall": {"temp": 28, "rain": 0.3, "condition": "Perfect"}
            },
        }
        
        # Determine season
        if month in [12, 1, 2]:
            season = "winter"
        elif month in [3, 4, 5]:
            season = "spring"
        elif month in [6, 7, 8]:
            season = "summer"
        else:
            season = "fall"
        
        # Default pattern if destination not in detailed patterns
        default = {"temp": 20, "rain": 0.4, "condition": "Moderate"}
        pattern = weather_patterns.get(destination, {}).get(season, default)
        
        return {
            "temperature": pattern["temp"],
            "rain_probability": pattern["rain"],
            "condition": pattern["condition"],
            "season": season
        }
    
    def get_best_time_to_visit(self, destination):
        """Returns best months to visit based on weather patterns"""
        best_times = {
            "Paris": ["April-June", "September-October"],
            "Tokyo": ["March-May", "September-November"],
            "New York": ["April-June", "September-November"],
            "Barcelona": ["May-June", "September-October"],
            "Bali": ["April-October"],
            "Dubai": ["November-March"],
            "London": ["May-September"],
            "Sydney": ["September-November", "March-May"],
        }
        return best_times.get(destination, ["Year-round"])


# ============================================================================
# COST FORECASTING MODULE (cost_analyzer.py)
# ============================================================================

class CostAnalyzer:
    """Analyzes and forecasts travel costs"""
    
    def __init__(self):
        # Sample cost data (USD per day)
        self.cost_data = {
            "Paris": {"low": 80, "mid": 150, "high": 300},
            "Tokyo": {"low": 70, "mid": 130, "high": 280},
            "New York": {"low": 100, "mid": 180, "high": 350},
            "Barcelona": {"low": 60, "mid": 110, "high": 220},
            "Bali": {"low": 30, "mid": 60, "high": 150},
            "Dubai": {"low": 90, "mid": 170, "high": 400},
            "London": {"low": 90, "mid": 160, "high": 320},
            "Sydney": {"low": 85, "mid": 150, "high": 300},
        }
        
        self.flight_costs = {
            "Paris": 600, "Tokyo": 900, "New York": 400,
            "Barcelona": 550, "Bali": 800, "Dubai": 700,
            "London": 500, "Sydney": 1100
        }
    
    def get_cost_estimate(self, destination, budget_level="mid", days=7):
        """Calculate total trip cost estimate"""
        daily_cost = self.cost_data.get(destination, {"mid": 100})[budget_level]
        flight_cost = self.flight_costs.get(destination, 600)
        
        total = (daily_cost * days) + flight_cost
        
        return {
            "daily_cost": daily_cost,
            "flight_cost": flight_cost,
            "accommodation": daily_cost * 0.5,
            "food": daily_cost * 0.3,
            "activities": daily_cost * 0.2,
            "total": total,
            "per_day": daily_cost
        }
    
    def get_seasonal_price_factor(self, month):
        """Returns price multiplier based on season"""
        # High season months (summer + holidays)
        if month in [6, 7, 8, 12]:
            return 1.3
        # Shoulder season
        elif month in [4, 5, 9, 10]:
            return 1.0
        # Low season
        else:
            return 0.8


# ============================================================================
# RECOMMENDATION ENGINE (recommender.py)
# ============================================================================

class DestinationRecommender:
    """Recommends destinations based on preferences"""
    
    def __init__(self, weather_api, cost_analyzer):
        self.weather_api = weather_api
        self.cost_analyzer = cost_analyzer
    
    def score_destination(self, destination, preferences):
        """Score destination based on user preferences"""
        score = 0
        reasons = []
        
        # Weather scoring
        weather = self.weather_api.get_weather_forecast(destination)
        if preferences["preferred_temp"]:
            temp_diff = abs(weather["temperature"] - preferences["preferred_temp"])
            weather_score = max(0, 100 - (temp_diff * 5))
            score += weather_score * 0.4
            if weather_score > 70:
                reasons.append(f"Great temperature (~{weather['temperature']}Â°C)")
        
        # Cost scoring
        costs = self.cost_analyzer.get_cost_estimate(
            destination, 
            preferences["budget_level"], 
            preferences["days"]
        )
        
        max_budget = preferences["max_budget"]
        if costs["total"] <= max_budget:
            budget_score = ((max_budget - costs["total"]) / max_budget) * 100
            score += budget_score * 0.4
            reasons.append(f"Within budget (${costs['total']:.0f})")
        else:
            score += 0  # Over budget
            reasons.append(f"Over budget (${costs['total']:.0f})")
        
        # Best time bonus
        best_times = self.weather_api.get_best_time_to_visit(destination)
        current_month = datetime.now().strftime("%B")
        if any(current_month in period for period in best_times):
            score += 20
            reasons.append("Peak season to visit")
        
        return {
            "score": min(score, 100),
            "reasons": reasons,
            "weather": weather,
            "costs": costs
        }
    
    def get_recommendations(self, preferences, top_n=5):
        """Get top N destination recommendations"""
        results = []
        
        for destination in self.weather_api.destinations.keys():
            analysis = self.score_destination(destination, preferences)
            results.append({
                "destination": destination,
                "analysis": analysis
            })
        
        # Sort by score
        results.sort(key=lambda x: x["analysis"]["score"], reverse=True)
        return results[:top_n]


# ============================================================================
# GUI MODULE (gui.py)
# ============================================================================

class TravelAnalyzerGUI:
    """Main GUI application"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("Travel Destination Analyzer")
        self.root.geometry("900x700")
        
        # Initialize modules
        self.weather_api = WeatherAPI()
        self.cost_analyzer = CostAnalyzer()
        self.recommender = DestinationRecommender(self.weather_api, self.cost_analyzer)
        
        self.setup_ui()
    
    def setup_ui(self):
        """Create the user interface"""
        # Title
        title = tk.Label(
            self.root, 
            text="ðŸŒ Travel Destination Analyzer",
            font=("Arial", 20, "bold"),
            fg="#2c3e50"
        )
        title.pack(pady=20)
        
        # Preferences Frame
        pref_frame = ttk.LabelFrame(self.root, text="Travel Preferences", padding=20)
        pref_frame.pack(padx=20, pady=10, fill="x")
        
        # Budget
        ttk.Label(pref_frame, text="Maximum Budget ($):").grid(row=0, column=0, sticky="w", pady=5)
        self.budget_var = tk.StringVar(value="2000")
        ttk.Entry(pref_frame, textvariable=self.budget_var, width=15).grid(row=0, column=1, pady=5)
        
        # Budget Level
        ttk.Label(pref_frame, text="Budget Level:").grid(row=1, column=0, sticky="w", pady=5)
        self.budget_level_var = tk.StringVar(value="mid")
        budget_combo = ttk.Combobox(
            pref_frame, 
            textvariable=self.budget_level_var,
            values=["low", "mid", "high"],
            state="readonly",
            width=13
        )
        budget_combo.grid(row=1, column=1, pady=5)
        
        # Trip Duration
        ttk.Label(pref_frame, text="Trip Duration (days):").grid(row=2, column=0, sticky="w", pady=5)
        self.days_var = tk.StringVar(value="7")
        ttk.Entry(pref_frame, textvariable=self.days_var, width=15).grid(row=2, column=1, pady=5)
        
        # Preferred Temperature
        ttk.Label(pref_frame, text="Preferred Temp (Â°C):").grid(row=3, column=0, sticky="w", pady=5)
        self.temp_var = tk.StringVar(value="22")
        ttk.Entry(pref_frame, textvariable=self.temp_var, width=15).grid(row=3, column=1, pady=5)
        
        # Analyze Button
        analyze_btn = tk.Button(
            self.root,
            text="Find Best Destinations",
            command=self.analyze_destinations,
            bg="#3498db",
            fg="white",
            font=("Arial", 12, "bold"),
            padx=20,
            pady=10
        )
        analyze_btn.pack(pady=20)
        
        # Results Frame
        results_frame = ttk.LabelFrame(self.root, text="Recommendations", padding=10)
        results_frame.pack(padx=20, pady=10, fill="both", expand=True)
        
        # Results Text with Scrollbar
        text_frame = tk.Frame(results_frame)
        text_frame.pack(fill="both", expand=True)
        
        scrollbar = ttk.Scrollbar(text_frame)
        scrollbar.pack(side="right", fill="y")
        
        self.results_text = tk.Text(
            text_frame,
            wrap="word",
            yscrollcommand=scrollbar.set,
            font=("Courier", 10)
        )
        self.results_text.pack(side="left", fill="both", expand=True)
        scrollbar.config(command=self.results_text.yview)
        
        # Map Button
        map_btn = tk.Button(
            self.root,
            text="View Interactive Map",
            command=self.show_map,
            bg="#27ae60",
            fg="white",
            font=("Arial", 11),
            padx=15,
            pady=8
        )
        map_btn.pack(pady=10)
        
        self.current_recommendations = []
    
    def analyze_destinations(self):
        """Analyze and display destination recommendations"""
        try:
            preferences = {
                "max_budget": float(self.budget_var.get()),
                "budget_level": self.budget_level_var.get(),
                "days": int(self.days_var.get()),
                "preferred_temp": float(self.temp_var.get())
            }
            
            # Get recommendations
            recommendations = self.recommender.get_recommendations(preferences)
            self.current_recommendations = recommendations
            
            # Display results
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "=" * 80 + "\n")
            self.results_text.insert(tk.END, "TOP DESTINATION RECOMMENDATIONS\n")
            self.results_text.insert(tk.END, "=" * 80 + "\n\n")
            
            for i, rec in enumerate(recommendations, 1):
                dest = rec["destination"]
                analysis = rec["analysis"]
                
                self.results_text.insert(tk.END, f"#{i} - {dest}\n", "title")
                self.results_text.insert(tk.END, f"{'â”€' * 80}\n")
                self.results_text.insert(tk.END, f"Match Score: {analysis['score']:.1f}/100\n\n")
                
                # Weather info
                weather = analysis["weather"]
                self.results_text.insert(tk.END, "ðŸŒ¤ï¸  WEATHER:\n")
                self.results_text.insert(tk.END, f"   Temperature: {weather['temperature']}Â°C\n")
                self.results_text.insert(tk.END, f"   Condition: {weather['condition']}\n")
                self.results_text.insert(tk.END, f"   Rain Probability: {weather['rain_probability']*100:.0f}%\n\n")
                
                # Cost breakdown
                costs = analysis["costs"]
                self.results_text.insert(tk.END, "ðŸ’° COST ESTIMATE:\n")
                self.results_text.insert(tk.END, f"   Flight: ${costs['flight_cost']:.0f}\n")
                self.results_text.insert(tk.END, f"   Daily: ${costs['per_day']:.0f}\n")
                self.results_text.insert(tk.END, f"   Total ({preferences['days']} days): ${costs['total']:.0f}\n\n")
                
                # Best time to visit
                best_times = self.weather_api.get_best_time_to_visit(dest)
                self.results_text.insert(tk.END, f"ðŸ“… Best Time: {', '.join(best_times)}\n\n")
                
                # Reasons
                self.results_text.insert(tk.END, "âœ¨ Why this destination:\n")
                for reason in analysis["reasons"]:
                    self.results_text.insert(tk.END, f"   â€¢ {reason}\n")
                
                self.results_text.insert(tk.END, "\n" + "=" * 80 + "\n\n")
            
        except ValueError as e:
            messagebox.showerror("Input Error", "Please enter valid numeric values!")
    
    def show_map(self):
        """Generate and display interactive map"""
        if not self.current_recommendations:
            messagebox.showwarning("No Data", "Please analyze destinations first!")
            return
        
        # Create map centered on world
        m = folium.Map(location=[20, 0], zoom_start=2)
        
        # Add markers for each destination
        for rec in self.current_recommendations:
            dest = rec["destination"]
            analysis = rec["analysis"]
            coords = self.weather_api.destinations[dest]
            
            # Create popup content
            popup_html = f"""
            <div style="width: 200px">
                <h4>{dest}</h4>
                <b>Score:</b> {analysis['score']:.1f}/100<br>
                <b>Temp:</b> {analysis['weather']['temperature']}Â°C<br>
                <b>Cost:</b> ${analysis['costs']['total']:.0f}<br>
                <b>Condition:</b> {analysis['weather']['condition']}
            </div>
            """
            
            # Color based on score
            if analysis['score'] >= 80:
                color = 'green'
            elif analysis['score'] >= 60:
                color = 'orange'
            else:
                color = 'red'
            
            folium.Marker(
                location=[coords['lat'], coords['lon']],
                popup=folium.Popup(popup_html, max_width=250),
                tooltip=f"{dest} - Score: {analysis['score']:.1f}",
                icon=folium.Icon(color=color, icon='info-sign')
            ).add_to(m)
        
        # Save map
        map_file = "travel_destinations_map.html"
        m.save(map_file)
        
        # Open in browser
        webbrowser.open('file://' + os.path.abspath(map_file))
        messagebox.showinfo("Map Generated", f"Interactive map opened in browser!\nSaved as: {map_file}")


# ============================================================================
# MAIN APPLICATION
# ============================================================================

def main():
    root = tk.Tk()
    app = TravelAnalyzerGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
